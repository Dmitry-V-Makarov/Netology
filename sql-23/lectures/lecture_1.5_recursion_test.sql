create table test (
	date_event timestamp,
	field varchar(50),
	old_value varchar(50),
	new_value varchar(50)
)
insert into test (date_event, field, old_value, new_value)
values
('2017-08-05', 'val', 'ABC', '800'),
('2017-07-26', 'pin', '', '10-AA'),
('2017-07-21', 'pin', '300-L', ''),
('2017-07-26', 'con', 'CC800', 'null'),
('2017-08-11', 'pin', 'EKH', 'ABC-500'),
('2017-08-16', 'val', '990055', '100')
select * from test order by date(date_event)

/*¬ данной таблице хран€т информацию по изменению "статуса" дл€ каждого типа пол€ (field ).
“о есть, есть поле pin, на 21.07.2017 было изменено значение, соответственно новое (new_value ) стало '' (пуста€ строка) и старое  (old_value), записалось как '300-L'.
ƒалее 26.07.2017 изменили значение с '' (пуста€ строка) на '10-AA'. » так по разным пол€м в разные даты были какие-то изменени€ значений.

«адача: составить запрос таким образом, что бы в новой результирующей таблице был календарь изменени€ значений дл€ каждого пол€.
¬сего три столбца: дата, поле, текущий статус.
“о есть дл€ каждого пол€ будет отображение каждого дн€ с отображением текущего статуса.   примеру, дл€ пол€ pin на 21.07.2017 статус будет  '' (пуста€ строка), на 22.07.2017 -  '' (пуста€ строка). и т.д. до 26.07.2017, где статус станет '10-AA'
–ешение должно быть универсальным дл€ любого SQL, не только под PostgreSQL ;)
(маленька€ таблица исходные данные, больша€ - фрагмент нужного результата)*/